## Advent of Code 2024
This winter I am trying to learn `golang` with AoC 2024!

Happy Holidays!

```

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⢠⣤⡾⠋⠷⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡆⣠⡰⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⠏⣿⠗⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣤⣘⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⡿⠁⢉⣟⠛⢷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠸⣟⣹⠉⠀⠈⣿⣌⡏⠀⢈⣹⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀
⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⣿⡥⢤⣆⣀⣵⣄⣑⣦⢬⣽⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣾⣁⣬⣽⣶⠿⢋⡬⣍⠀⠻⣄⡀⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⣜⣿⠟⠛⠉⢉⣅⠀⠀⢸⣢⣸⠇⠀⠈⢽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡩⡓⠁⠀⠈⣯⣈⡟⠀⠀⠀⠀⠀⠀⠀⠀⠉⣽⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀
*⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡟⠟⣀⣠⠀⢉⡀⠁⢀⠀⠀⡀⠀⢠⣀⠈⢻⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢉⡿⠹⠷⠒⡿⠤⡖⠋⠓⠦⠽⠗⠺⠏⢻⡍⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀    *
⠀⠀⠀⠀⠀*⠀⠀⢠⣀⣠⢾⢷⣶⣤⣄⣀⣀⣀⣀⣀⣀⣀⣤⣴⣶⡾⠿⣦⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢈⣿⢆⠅⠀⢀⣉⣉⠓⠛⠛⠛⠓⠒⡏⠉⠉⠀⠀⠀⠰⣿⡃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣤⡴⠞⠕⠁⠀⠀⢺⣿⣿⠆⠀⠀⠀⠐⡞⡙⡖⠀⠀⠀⠀⠀⠈⠛⠦⣤⡄⠀⠀⠀⠀*   
⠀⠀⠀⠀⠀⠀⠈⢛⣶⠞⢀⡀⠀⢀⠉⠁⠀⠀⠀⢀⠀⠋⠉⠃⠀⡀⠀⠀⣀⠘⢶⡞⠛⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣤⡿⠻⠿⠒⠚⠿⠴⠖⣯⠤⠔⠋⠳⣤⣼⡖⠦⠽⠓⠒⠾⠿⠻⣇⠀⠀⠀⠀⠀⠀⠀       *
⠀⠀⠀⠀⢰⣞⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣻⡀⠀⠀⣠⠾⢧⠀⠀⠈⠙⢓⣶⠀⠀⠀⠀
⢠⡴⠶⠚⠋⠋⠁⠀⠀⠀⠀⠀⣴⠛⣦⠄⠀⠀⠀⣀⣀⠀⢻⣧⠀⠀⠻⣤⡼⠁⠀⠀⠀⠀⠉⠛⠲⢶⣤
⠀⠙⠓⢷⡶⠂⠀⠀⠀⠀⠀⠀⠸⠒⠗⠀⠀⠀⢸⡁⢈⡇⠈⢿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⢲⣖⠖⠛⠁
⠀⠀⠀⠾⠷⣶⣏⣀⣀⣤⠆⠀⡀⠀⠀⠀⢠⠀⢀⣩⡉⠀⣄⠀⠻⣷⣄⡀⠀⢦⣄⣀⣘⣷⣶⠿⠀⠀⠀
⠀⠀⠀⠀⠀⠉⠉⠉⠙⠛⠛⣿⣥⣤⠴⠾⠿⢾⡿⢿⣿⣷⠾⠗⢶⢬⣿⣿⠛⠚⠋⠉⠉⠉⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⠙⣿⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠒⠒⠒⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

```
### Solutions
#### Day 1
Brute force the answer.
#### Day 2
Brute force check for all possible cases.
#### Day 3
Use regex to extract valid `muls` and functions `do()` & `don't()`.
#### Day 4
Pivot on `X` in first part and `A` in second part for the search.
#### Day 5
Create an adjacency matrix and check for validity of each pair in the list.
#### Day 6
- BFS can be used in part 1. 
- Brute force can be used in part 2 by checking for all positions if adding an obstacle leads to a cycle. Cycle can be detected by maintaining if we have already visited a cell with the same directional vectors.
#### Day 7
- Bitmasking can be used to try all combinations. This can be done in $O(2^{n})$.
- Instead of two options, we now have three options for each operator. Brute force can be done with time complexity $O(3^{n})$.
#### Day 8
- For each cell, we can check if it can be an antinode with respect to any antenna. Checking if a cell is in same direction with two antennas, we can use dot product and check if the two antennas and the cell form a collinear line.
#### Day 9
Simulate the process by maintaining blocks of info containing number of files, number of spaces and id of block.
#### Day 10
Run a dfs from each `trailhead` and maintain unique trail-ends in a datastructure like Set/Map.
#### Day 11
- For first part, we can simulate the process.
- For second part, it is not feasible to simulate the process for a large number of steps. We can treat each stone as an individual problem and use recursive dp to avoid recomputing of overlapping subproblems.
#### Day 12
- For first part, we can run dfs/bfs and check for each cell what is its contribution to the perimeter and area.
- For second part, we can maintain the borders along with their direction relative to the cell we encounter during the dfs/bfs from first part and then for every border we can sweep left / right relative to the direction to include other borders as part of one side.
#### Day 13
- For first part, we can try for all combinations of pushes since a button can only be pushed a maximum of 100 times.
- For second part, There will be either an unique solution or no solution exists. We can formulate the unknowns - number of pushes to button A and B as linear equations in two variables and solve the equations.
#### Day 14
- New positions at time `t` are simply $x + v_{x}t$ and $y + v_{y}t$ for an infinite grid. We can adjust the new positions to be bounded in a 101x103 grid using simple maths.
- For second part, I just simulated and printed all possible arrangements till 10000 seconds and searched for a pattern with many `#` in a row, Fortunately there were only 33 possibilities.
#### Day 15
- Simple simulation, pushing of boxes can be simulated via recursion.
#### Day 16
- Run dijkstra from source node with state as $(cost, x, y, direction)$.
- Run a reverse dijkstra from the sink node backtracking the path, in the end a node $x$ would fall on an optimal path if for any $d \{\in d_1,\dots d_4\}$ $dis(src \to x, dir: d) + dis(sink \to x, dir: d) = \min_{d \in d_1,\dots d_4}dis(src \to sink, dir: d)$