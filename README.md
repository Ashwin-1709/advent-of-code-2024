## Advent of Code 2024
This winter I am trying to learn `golang` with AoC 2024!

Happy Holidays!

```

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⢠⣤⡾⠋⠷⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡆⣠⡰⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢿⠏⣿⠗⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣤⣘⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⡿⠁⢉⣟⠛⢷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⠸⣟⣹⠉⠀⠈⣿⣌⡏⠀⢈⣹⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*⠀⠀
⠀⠀*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⣿⡥⢤⣆⣀⣵⣄⣑⣦⢬⣽⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣾⣁⣬⣽⣶⠿⢋⡬⣍⠀⠻⣄⡀⠀⠀⠀⠀*⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀*⠀⠀⠀⠀⣜⣿⠟⠛⠉⢉⣅⠀⠀⢸⣢⣸⠇⠀⠈⢽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡩⡓⠁⠀⠈⣯⣈⡟⠀⠀⠀⠀⠀⠀⠀⠀⠉⣽⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀
*⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡟⠟⣀⣠⠀⢉⡀⠁⢀⠀⠀⡀⠀⢠⣀⠈⢻⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢉⡿⠹⠷⠒⡿⠤⡖⠋⠓⠦⠽⠗⠺⠏⢻⡍⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀    *
⠀⠀⠀⠀⠀*⠀⠀⢠⣀⣠⢾⢷⣶⣤⣄⣀⣀⣀⣀⣀⣀⣀⣤⣴⣶⡾⠿⣦⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢈⣿⢆⠅⠀⢀⣉⣉⠓⠛⠛⠛⠓⠒⡏⠉⠉⠀⠀⠀⠰⣿⡃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⣤⡴⠞⠕⠁⠀⠀⢺⣿⣿⠆⠀⠀⠀⠐⡞⡙⡖⠀⠀⠀⠀⠀⠈⠛⠦⣤⡄⠀⠀⠀⠀*   
⠀⠀⠀⠀⠀⠀⠈⢛⣶⠞⢀⡀⠀⢀⠉⠁⠀⠀⠀⢀⠀⠋⠉⠃⠀⡀⠀⠀⣀⠘⢶⡞⠛⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣤⡿⠻⠿⠒⠚⠿⠴⠖⣯⠤⠔⠋⠳⣤⣼⡖⠦⠽⠓⠒⠾⠿⠻⣇⠀⠀⠀⠀⠀⠀⠀       *
⠀⠀⠀⠀⢰⣞⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣻⡀⠀⠀⣠⠾⢧⠀⠀⠈⠙⢓⣶⠀⠀⠀⠀
⢠⡴⠶⠚⠋⠋⠁⠀⠀⠀⠀⠀⣴⠛⣦⠄⠀⠀⠀⣀⣀⠀⢻⣧⠀⠀⠻⣤⡼⠁⠀⠀⠀⠀⠉⠛⠲⢶⣤
⠀⠙⠓⢷⡶⠂⠀⠀⠀⠀⠀⠀⠸⠒⠗⠀⠀⠀⢸⡁⢈⡇⠈⢿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⢲⣖⠖⠛⠁
⠀⠀⠀⠾⠷⣶⣏⣀⣀⣤⠆⠀⡀⠀⠀⠀⢠⠀⢀⣩⡉⠀⣄⠀⠻⣷⣄⡀⠀⢦⣄⣀⣘⣷⣶⠿⠀⠀⠀
⠀⠀⠀⠀⠀⠉⠉⠉⠙⠛⠛⣿⣥⣤⠴⠾⠿⢾⡿⢿⣿⣷⠾⠗⢶⢬⣿⣿⠛⠚⠋⠉⠉⠉⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⠙⣿⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠒⠒⠒⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

```
### Solutions
#### Day 1
Brute force the answer.
#### Day 2
Brute force check for all possible cases.
#### Day 3
Use regex to extract valid `muls` and functions `do()` & `don't()`.
#### Day 4
Pivot on `X` in first part and `A` in second part for the search.
#### Day 5
Create an adjacency matrix and check for validity of each pair in the list.
#### Day 6
- BFS can be used in part 1. 
- Brute force can be used in part 2 by checking for all positions if adding an obstacle leads to a cycle. Cycle can be detected by maintaining if we have already visited a cell with the same directional vectors.
#### Day 7
- Bitmasking can be used to try all combinations. This can be done in $O(2^{n})$.
- Instead of two options, we now have three options for each operator. Brute force can be done with time complexity $O(3^{n})$.
#### Day 8
- For each cell, we can check if it can be an antinode with respect to any antenna. Checking if a cell is in same direction with two antennas, we can use dot product and check if the two antennas and the cell form a collinear line.
#### Day 9
Simulate the process by maintaining blocks of info containing number of files, number of spaces and id of block.
#### Day 10
Run a dfs from each `trailhead` and maintain unique trail-ends in a datastructure like Set/Map.
#### Day 11
- For first part, we can simulate the process.
- For second part, it is not feasible to simulate the process for a large number of steps. We can treat each stone as an individual problem and use recursive dp to avoid recomputing of overlapping subproblems.
#### Day 12
- For first part, we can run dfs/bfs and check for each cell what is its contribution to the perimeter and area.
- For second part, we can maintain the borders along with their direction relative to the cell we encounter during the dfs/bfs from first part and then for every border we can sweep left / right relative to the direction to include other borders as part of one side.
#### Day 13
- For first part, we can try for all combinations of pushes since a button can only be pushed a maximum of 100 times.
- For second part, There will be either an unique solution or no solution exists. We can formulate the unknowns - number of pushes to button A and B as linear equations in two variables and solve the equations.
#### Day 14
- New positions at time `t` are simply $x + v_{x}t$ and $y + v_{y}t$ for an infinite grid. We can adjust the new positions to be bounded in a 101x103 grid using simple maths.
- For second part, I just simulated and printed all possible arrangements till 10000 seconds and searched for a pattern with many `#` in a row, Fortunately there were only 33 possibilities.
#### Day 15
- Simple simulation, pushing of boxes can be simulated via recursion.
#### Day 16
- Run dijkstra from source node with state as $(cost, x, y, direction)$.
- Run a reverse dijkstra from the sink node backtracking the path, in the end a node $x$ would fall on an optimal path if for any $d \in d_1,\dots d_4$ $dis(src \to x, dir: d) + dis(sink \to x, dir: d) = \min_{d \in d_1,\dots d_4}dis(src \to sink, dir: d)$
#### Day 18
- Run bfs from $(0, 0)$ to $(n - 1, m - 1)$ after simulating the blocks.
- We can do a binary search in this case, if path is blocked at time $t$, it will be blocked at time $t + 1$ as well. So we can do binary search and find the first byte which causes the path to be blocked.
#### Day 19
We can use dp to count the number of ways a towel can be built with given patterns, $dp[i] \to$ number of ways that $towel[i \dots n]$ can be built where $n$ is the length of the towel. 
#### Day 20
- Run bfs to get shortest distance for all points from both $S$ and $E$. Then for each wall (`#`), find pair of valid neighbours and check if taking the cheat across the wall reduces the time.
- For any pair of valid nodes, we can find the manhattan distance (this is the min distance if we take cheat between the nodes). If this is within the cheat limit, we can try taking the cheat and check how much it reduces the time.
#### Day 23
- Brute force for all nodes beginning with `t`.
- Finding the largest clique of a graph is NP-Hard. I assumed the input was in a way that the clique size won't blow up so I found all cliques of $size \leq 20$ and the largest clique was one of them.
#### Day 25
- Brute force the possible combinations for each lock. Since the computation is independent, it can be done asynchronously for each lock using `goroutines`, `channels` & `sync.Waitgroup`.